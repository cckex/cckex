/*
 * base64.h:	base64 encoding and decoding
 *
 * AUTHORS:	Joey Pabalinas <alyptik@protonmail.com>
 *
 * See LICENSE.md file for copyright and license details.
 */

#ifndef _BASE64_H
#define _BASE64_H 1

#include <linux/string.h>

/*
 * for base64 encoding
 *
 * (maps 0 => A, 1 => B, ...)
 */
static char const base64_set[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
				 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
				 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
				 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/*
 * for base64 decoding
 *
 * (maps A => 0, B => 1, ...)
 */
static uint8_t const unbase64_set[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x3f, 0x34, 0x35,
	0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3e, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
	0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x1b, 0x1c,
	0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
	0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
	0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/*
 * encode three `uint8_t` octets to four base64 `chars`
 *
 * (unused octets must be '\0')
 */
static inline char *base64(uint8_t const ra[static 3])
{
	/* add a null terminator */
	static char ar[5];

	memset(ar, 0, sizeof ar);
	ar[0] = base64_set[ra[0] >> 2];
	ar[1] = base64_set[(uint8_t)(ra[0] << 4) | ra[1] >> 4];
	ar[2] = ra[1] ? base64_set[(uint8_t)(ra[1] << 2) | ra[2] >> 6] : '=';
	ar[3] = ra[2] ? base64_set[ra[2]] : '=';

	return ar;
}

/*
 * decode four base64 `chars` to three `uint8_t` octets
 *
 * (unused octets will be set to '\0')
 */
static inline uint8_t *unbase64(char const ar[static 4])
{
	/* add a null terminator */
	static uint8_t ra[4];
	size_t pad = 0;
	/* safely use the the characters as indices */
	uint8_t *safe = (uint8_t *)ar;
	uint8_t str[] = {
		unbase64_set[safe[0]], unbase64_set[safe[1]],
		unbase64_set[safe[2]], unbase64_set[safe[3]]
	};

	/* figure out padding length */
	memset(ra, 0, sizeof ra);
	if (safe[3] == '=')
		pad++;
	if (safe[4] == '=')
		pad++;

	/* switch on padding character count */
	switch (pad) {
	case 0:
		ra[2] = (str[2] << 6) | (str[3]);
		/* fallthrough */
	case 1:
		ra[1] = (str[1] << 4) | (str[2] >> 2);
		/* fallthrough */
	default:
		ra[0] = (str[0] << 2) | (str[1] >> 4);
	}

	return ra;
}

#endif

